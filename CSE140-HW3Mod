#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define MAX_INSTRUCTIONS 100

// Global variables
int pc = 0;
int next_pc = 4;
int branch_target = 0;
int total_clock_cycles = 0;
char instruction_memory[MAX_INSTRUCTIONS][33]; // Store the 32-bit instructions
int instruction_count = 0;

int rf[32] = {0}; // Register file
int d_mem[32] = {0}; // Data memory

// Register names for clearer output
const char* reg_names[32] = {
    "zero", "ra", "sp", "gp", "tp", "t0", "t1", "t2", "s0", "s1",
    "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "s2", "s3",
    "s4", "s5", "s6", "s7", "s8", "s9", "s10", "s11", "t3", "t4",
    "t5", "t6"
};

// Utility: binary substring to decimal
int bin_to_dec(const char *bin, int start, int len, int sign_extend) {
    int val = 0;
    for (int i = 0; i < len; i++) {
        val = (val << 1) | (bin[start + i] - '0');
    }
    
    // Sign extension if needed
    if (sign_extend && bin[start] == '1') {
        val |= ((-1) << len);
    }
    return val;
}

// Load instructions from a file
void load_instructions(const char *filename) {
    FILE *file = fopen(filename, "r");
    if (!file) {
        perror("Failed to open instruction file");
        exit(1);
    }
    
    instruction_count = 0;
    char line[100];
    
    while (fgets(line, sizeof(line), file)) {
        // Remove newline if present
        size_t len = strlen(line);
        if (len > 0 && (line[len-1] == '\n' || line[len-1] == '\r'))
            line[--len] = '\0';
        
        if (len == 32) { // Valid 32-bit instruction
            strcpy(instruction_memory[instruction_count++], line);
        }
    }
    
    fclose(file);
}

// Initialize memory and registers
void initialize_memory() {
    // Reset all registers and memory
    memset(rf, 0, sizeof(rf));
    memset(d_mem, 0, sizeof(d_mem));
    
    // Initialize registers as per project specification
    rf[1] = 0x20;  // x1 (ra)
    rf[2] = 0x5;   // x2 (sp)
    rf[10] = 0x70; // x10 (a0)
    rf[11] = 0x4;  // x11 (a1)
    
    d_mem[28] = 0x5;  // Memory at 0x70 (word address 28)
    d_mem[29] = 0x10; // Memory at 0x74 (word address 29)
}

// Process one instruction
void process_instruction(int instr_index) {
    // Increment cycle counter
    total_clock_cycles++;
    
    // Get the instruction
    char *inst = instruction_memory[instr_index];
    
    // Save old register and memory values to track changes
    int old_rf[32];
    memcpy(old_rf, rf, sizeof(rf));
    
    int old_mem[32];
    memcpy(old_mem, d_mem, sizeof(d_mem));
    
    // Extract instruction fields
    int opcode = bin_to_dec(inst, 25, 7, 0);
    int rd = bin_to_dec(inst, 20, 5, 0);
    int funct3 = bin_to_dec(inst, 17, 3, 0);
    int rs1 = bin_to_dec(inst, 12, 5, 0);
    int rs2 = bin_to_dec(inst, 7, 5, 0);
    int funct7 = bin_to_dec(inst, 0, 7, 0);
    
    // Calculate immediates based on instruction type
    int imm = 0;
    
    // R-type: add, sub, and, or
    if (opcode == 0b0110011) {
        if (funct3 == 0 && funct7 == 0) {          // add
            rf[rd] = rf[rs1] + rf[rs2];
        } else if (funct3 == 0 && funct7 == 32) {  // sub
            rf[rd] = rf[rs1] - rf[rs2];
        } else if (funct3 == 7) {                  // and
            rf[rd] = rf[rs1] & rf[rs2];
        } else if (funct3 == 6) {                  // or
            rf[rd] = rf[rs1] | rf[rs2];
        }
    }
    // I-type: addi, lw
    else if (opcode == 0b0010011 || opcode == 0b0000011) {
        imm = bin_to_dec(inst, 0, 12, 1);
        
        if (opcode == 0b0010011) { // addi, andi, ori
            if (funct3 == 0) {          // addi
                rf[rd] = rf[rs1] + imm;
            } else if (funct3 == 7) {   // andi
                rf[rd] = rf[rs1] & imm;
            } else if (funct3 == 6) {   // ori
                rf[rd] = rf[rs1] | imm;
            }
        } else { // lw
            int addr = (rf[rs1] + imm) >> 2;  // Convert byte address to word address
            rf[rd] = d_mem[addr & 0x1F];      // Mask to get word within memory range
        }
    }
    // S-type: sw
    else if (opcode == 0b0100011) {
        imm = (bin_to_dec(inst, 0, 7, 0) << 5) | bin_to_dec(inst, 20, 5, 0);
        if ((imm >> 11) & 1) { // Sign extend
            imm |= (~0U << 12);
        }
        
        int addr = (rf[rs1] + imm) >> 2;  // Convert byte address to word address
        d_mem[addr & 0x1F] = rf[rs2];     // Mask to get word within memory range
    }
    // B-type: beq
    else if (opcode == 0b1100011) {
        imm = (bin_to_dec(inst, 0, 1, 0) << 12) |
              (bin_to_dec(inst, 1, 6, 0) << 5) |
              (bin_to_dec(inst, 20, 4, 0) << 1) |
              (bin_to_dec(inst, 24, 1, 0) << 11);
        
        if ((imm >> 12) & 1) { // Sign extend
            imm |= (~0U << 13);
        }
        
        if (rf[rs1] == rf[rs2]) {
            pc = pc + imm - 4;  // Adjust for the pc increment that follows
        }
    }
    
    // Update PC for next instruction
    pc += 4;
    
    // Print cycle results
    printf("total_clock_cycles %d :\n", total_clock_cycles);
    
    // Print register changes
    for (int i = 0; i < 32; i++) {
        if (rf[i] != old_rf[i]) {
            printf("%s is modified to 0x%x\n", reg_names[i], rf[i]);
        }
    }
    
    // Print memory changes
    for (int i = 0; i < 32; i++) {
        if (d_mem[i] != old_mem[i]) {
            printf("memory 0x%x is modified to 0x%x\n", i * 4, d_mem[i]);
        }
    }
    
    printf("pc is modified to 0x%x\n\n", pc);
}

// Main function
int main() {
    char filename[100];
    
    // Initialize memory and registers
    initialize_memory();
    
    // Get the program file name
    printf("Enter the program file name to run:\n");
    scanf("%s", filename);
    
    // Load instructions from file
    load_instructions(filename);
    
    // Reset PC and cycle count
    pc = 0;
    total_clock_cycles = 0;
    
    // Process each instruction
    while (pc / 4 < instruction_count) {
        process_instruction(pc / 4);
    }
    
    printf("program terminated:\n");
    printf("total execution time is %d cycles\n", total_clock_cycles);
    
    return 0;
}
