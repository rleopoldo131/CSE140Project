// Modified HW3 code to start CSE 140 Project - Single-Cycle RISC-V CPU
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define MAX_INSTRUCTIONS 100

// Global variables
int pc = 0;
int next_pc = 4;
int total_clock_cycles = 0;
char instruction_memory[MAX_INSTRUCTIONS][33];
int instruction_count = 0;
char current_instruction[33];

int rf[32] = {0}; // Register file
int d_mem[32] = {0}; // Data memory

// Control signals
int RegWrite = 0, Branch = 0, MemRead = 0, MemWrite = 0;
int ALUSrc = 0, MemToReg = 0, ALUOp = 0;
int alu_zero = 0;
int branch_target = 0;

// ALU and data path variables
int alu_result = 0;
int rd, rs1, rs2, imm;
int val1, val2;
int mem_data = 0;

// Utility: binary substring to decimal
int bin_to_dec(char *bin, int start, int len, int sign_extend) {
    int val = 0;
    for (int i = 0; i < len; i++) {
        val <<= 1;
        val |= (bin[start + i] - '0');
    }
    if (sign_extend && bin[start] == '1') {
        val -= (1 << len);
    }
    return val;
}

void Fetch() {
    strcpy(current_instruction, instruction_memory[pc / 4]);
    next_pc = pc + 4;
    pc = next_pc; // Later will be conditional on branch
}

void Decode() {
    char *inst = current_instruction;
    int opcode = bin_to_dec(inst, 25, 7, 0);
    rd = bin_to_dec(inst, 20, 5, 0);
    int funct3 = bin_to_dec(inst, 17, 3, 0);
    rs1 = bin_to_dec(inst, 12, 5, 0);
    rs2 = bin_to_dec(inst, 7, 5, 0);
    int funct7 = bin_to_dec(inst, 0, 7, 0);

    val1 = rf[rs1];
    val2 = rf[rs2];

    // Immediate for I-type (like addi, lw)
    imm = bin_to_dec(inst, 0, 12, 1);

    printf("Decoded: opcode=%d rd=x%d rs1=x%d rs2=x%d imm=%d funct3=%d funct7=%d\n",
           opcode, rd, rs1, rs2, imm, funct3, funct7);

    // Basic control signal logic for demo purposes (assumes add/addi/lw/sw only)
    if (opcode == 51) { // R-type (e.g., add)
        ALUSrc = 0; RegWrite = 1; ALUOp = 2;
    } else if (opcode == 19 || opcode == 3) { // I-type (addi, lw)
        ALUSrc = 1; RegWrite = 1; ALUOp = 2;
        MemRead = (opcode == 3);
        MemToReg = (opcode == 3);
    } else if (opcode == 35) { // S-type (sw)
        ALUSrc = 1; MemWrite = 1; ALUOp = 2;
    }
}

void Execute() {
    int operand2 = ALUSrc ? imm : val2;
    alu_result = val1 + operand2; // Only add for now
    alu_zero = (alu_result == 0);
    printf("Execute: ALU result=%d (val1=%d operand2=%d)\n", alu_result, val1, operand2);

    if (Branch && alu_zero) {
        pc = branch_target;
    }
}

void Mem() {
    if (MemRead) {
        mem_data = d_mem[(alu_result >> 2) & 0x1F];
        printf("Memory read: address=0x%x data=%d\n", alu_result, mem_data);
    }
    if (MemWrite) {
        d_mem[(alu_result >> 2) & 0x1F] = rf[rs2];
        printf("Memory write: address=0x%x data=%d\n", alu_result, rf[rs2]);
    }
}

void WriteBack() {
    if (RegWrite) {
        int write_val = MemToReg ? mem_data : alu_result;
        if (rd != 0) rf[rd] = write_val;
        printf("WriteBack: x%d is modified to 0x%x\n", rd, write_val);
    }
    total_clock_cycles++;
    printf("total_clock_cycles %d :\n", total_clock_cycles);
    printf("pc is modified to 0x%x\n\n", pc);
}

void load_instructions(const char *filename) {
    FILE *file = fopen(filename, "r");
    if (!file) {
        perror("Failed to open instruction file");
        exit(1);
    }
    while (fgets(instruction_memory[instruction_count], 33, file)) {
        instruction_memory[instruction_count][32] = '\0';
        instruction_count++;
    }
    fclose(file);
}

int main() {
    rf[1] = 0x20;
    rf[2] = 0x5;
    rf[10] = 0x70;
    rf[11] = 0x4;
    d_mem[28] = 0x5;
    d_mem[29] = 0x10;

    load_instructions("Project Part 1.txt");

    while (pc / 4 < instruction_count) {
        Fetch();
        Decode();
        Execute();
        Mem();
        WriteBack();
    }

    printf("Program terminated after %d cycles.\n", total_clock_cycles);
    return 0;
}
