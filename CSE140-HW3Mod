#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define max 100

// Global variables
int pc = 0;
int next_pc = 4;
int branch_target = 0;
int total_clock_cycles = 0;
char instruction_memory[max][33];
int instruction_count = 0;
char current_instruction[33];

int rf[32] = {0}; // Register file
int d_mem[32] = {0}; // Data memory

// Control signals
int RegWrite = 0, Branch = 0, MemRead = 0, MemWrite = 0;
int ALUSrc = 0, MemToReg = 0;
int ALUOp = 0;
int alu_zero = 0;
int alu_ctrl = 0;

// ALU and data path variables
int alu_result = 0;
int rd, rs1, rs2, imm;
int val1, val2;
int mem_data = 0;

// Register names for clearer output
const char* reg_names[32] = {
    "zero", "ra", "sp", "gp", "tp", "t0", "t1", "t2", "s0", "s1",
    "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "s2", "s3",
    "s4", "s5", "s6", "s7", "s8", "s9", "s10", "s11", "t3", "t4",
    "t5", "t6"
};

// Utility: binary substring to decimal
int bin_to_dec(const char *bin, int start, int len, int sign_extend) {
    int val = 0;
    for (int i = 0; i < len; i++) {
        val <<= 1;
        val |= (bin[start + i] - '0');
    }
    if (sign_extend && bin[start] == '1') {
        // Sign extension
        val |= ((-1) << len);
    }
    return val;
}

// Fetch the instruction from memory
void Fetch() {
    if (pc / 4 < instruction_count) {
        strcpy(current_instruction, instruction_memory[pc / 4]);
        next_pc = pc + 4;
    }
}

// Decode the instruction
void Decode() {
    char *inst = current_instruction;
    int opcode = bin_to_dec(inst, 25, 7, 0);
    rd = bin_to_dec(inst, 20, 5, 0);
    int funct3 = bin_to_dec(inst, 17, 3, 0);
    rs1 = bin_to_dec(inst, 12, 5, 0);
    rs2 = bin_to_dec(inst, 7, 5, 0);
    int funct7 = bin_to_dec(inst, 0, 7, 0);

    val1 = rf[rs1];
    val2 = rf[rs2];

    // I-type immediate (addi, lw)
    if (opcode == 0b0010011 || opcode == 0b0000011) { // addi, lw
        imm = bin_to_dec(inst, 0, 12, 1);
    }
    // S-type immediate (sw)
    else if (opcode == 0b0100011) { // sw
        imm = (bin_to_dec(inst, 0, 7, 0) << 5) | bin_to_dec(inst, 20, 5, 0);
        // Sign extend
        if ((imm >> 11) & 1) {
            imm |= (~0 << 12);
        }
    }
    // B-type immediate (beq)
    else if (opcode == 0b1100011) { // beq
        imm = (bin_to_dec(inst, 0, 1, 0) << 12) | 
              (bin_to_dec(inst, 1, 6, 0) << 5) | 
              (bin_to_dec(inst, 20, 4, 0) << 1) | 
              (bin_to_dec(inst, 24, 1, 0) << 11);
        // Sign extend
        if ((imm >> 12) & 1) {
            imm |= (~0 << 13);
        }
    }

    // Temporary simple control logic 
    RegWrite = 0; 
    MemRead = 0; 
    MemWrite = 0; 
    Branch = 0; 
    ALUSrc = 0; 
    MemToReg = 0; 
    ALUOp = 0;
    
    if (opcode == 0b0110011) { // R-type (add, sub, and, or)
        RegWrite = 1;
        ALUSrc = 0;
        ALUOp = 2;
        
        // Set ALU control based on funct3 and funct7
        if (funct3 == 0 && funct7 == 0) { // add
            alu_ctrl = 2; // ADD
        } else if (funct3 == 0 && funct7 == 32) { // sub
            alu_ctrl = 6; // SUB
        } else if (funct3 == 7) { // and
            alu_ctrl = 0; // AND
        } else if (funct3 == 6) { // or
            alu_ctrl = 1; // OR
        }
    } 
    else if (opcode == 0b0010011) { // I-type (addi, andi, ori)
        RegWrite = 1;
        ALUSrc = 1;
        
        if (funct3 == 0) { // addi
            alu_ctrl = 2; // ADD
        } else if (funct3 == 7) { // andi
            alu_ctrl = 0; // AND
        } else if (funct3 == 6) { // ori
            alu_ctrl = 1; // OR
        }
    }
    else if (opcode == 0b0000011) { // lw
        MemRead = 1;
        RegWrite = 1;
        ALUSrc = 1;
        MemToReg = 1;
        alu_ctrl = 2; // ADD for address calculation
    }
    else if (opcode == 0b0100011) { // sw
        MemWrite = 1;
        ALUSrc = 1;
        alu_ctrl = 2; // ADD for address calculation
    }
    else if (opcode == 0b1100011) { // beq
        Branch = 1;
        ALUSrc = 0;
        alu_ctrl = 6; // SUB for comparison
    }
}

// Execute the ALU operation
void Execute() {
    int operand2 = ALUSrc ? imm : val2;
    
    // ALU operations based on alu_ctrl
    switch(alu_ctrl) {
        case 0: // AND
            alu_result = val1 & operand2;
            break;
        case 1: // OR
            alu_result = val1 | operand2;
            break;
        case 2: // ADD
            alu_result = val1 + operand2;
            break;
        case 6: // SUB
            alu_result = val1 - operand2;
            break;
        default:
            alu_result = 0;
            break;
    }
    
    alu_zero = (alu_result == 0);
    
    // Calculate branch target
    branch_target = pc + imm; // For B-type instruction
}

// Memory access
void Mem() {
    if (MemRead) {
        int mem_addr = (alu_result >> 2) & 0x1F; // Convert byte address to word address (32-bit words)
        mem_data = d_mem[mem_addr];
    }
    
    if (MemWrite) {
        int mem_addr = (alu_result >> 2) & 0x1F; // Convert byte address to word address
        d_mem[mem_addr] = val2; // Write rs2 to memory
    }
}

// Write back to register file
void WriteBack() {
    if (RegWrite && rd != 0) { // x0 is hardwired to 0
        rf[rd] = MemToReg ? mem_data : alu_result;
    }
}

// Update the program counter
void UpdatePC() {
    // Update PC based on branch control and zero flag
    if (Branch && alu_zero) {
        pc = branch_target;
    } else {
        pc = next_pc;
    }
}

// Print state changes for the current cycle
void PrintCycleResults(int old_rf[32], int old_d_mem[32], int old_pc) {
    // Print cycle number
    printf("total_clock_cycles %d :\n", total_clock_cycles);
    
    // Print register changes
    for (int i = 0; i < 32; i++) {
        if (rf[i] != old_rf[i]) {
            printf("%s is modified to 0x%x\n", reg_names[i], rf[i]);
        }
    }
    
    // Print memory changes
    for (int i = 0; i < 32; i++) {
        if (d_mem[i] != old_d_mem[i]) {
            printf("memory 0x%x is modified to 0x%x\n", i * 4, d_mem[i]);
        }
    }
    
    printf("pc is modified to 0x%x\n\n", pc);
}

// Execute one complete instruction cycle
void ExecuteOneCycle() {
    // Save the old state to track changes
    int old_rf[32];
    memcpy(old_rf, rf, sizeof(rf));
    
    int old_d_mem[32];
    memcpy(old_d_mem, d_mem, sizeof(d_mem));
    
    int old_pc = pc;
    
    // Execute all pipeline stages for this instruction
    Fetch();
    Decode();
    Execute();
    Mem();
    WriteBack();
    UpdatePC();
    
    // Increment cycle counter after completing a full instruction
    total_clock_cycles++;
    
    // Print results for this cycle
    PrintCycleResults(old_rf, old_d_mem, old_pc);
}

// Load instructions from a file
void load_instructions(const char *filename) {
    FILE *file = fopen(filename, "r");
    if (!file) {
        perror("Failed to open instruction file");
        exit(1);
    }
    
    instruction_count = 0;
    char line[100];
    
    while (fgets(line, sizeof(line), file)) {
        // Remove newline if present
        size_t len = strlen(line);
        if (len > 0 && (line[len-1] == '\n' || line[len-1] == '\r'))
            line[--len] = '\0';
        
        if (len >= 32) { // Valid 32-bit instruction (may have extra chars)
            // Copy only the 32 bits we need
            strncpy(instruction_memory[instruction_count], line, 32);
            instruction_memory[instruction_count][32] = '\0';
            instruction_count++;
        }
    }
    fclose(file);
}

// Initialize memory and registers
void initialize_memory() {
    // Initialize all registers and memory to zero
    for (int i = 0; i < 32; i++) {
        rf[i] = 0;
        d_mem[i] = 0;
    }
    
    // Initialize registers as per project specification for Part 1
    rf[1] = 0x20;  // x1
    rf[2] = 0x5;   // x2
    rf[10] = 0x70; // x10
    rf[11] = 0x4;  // x11
    
    // Initialize memory as per project specification
    d_mem[28] = 0x5;  // 0x70 / 4 = 28
    d_mem[29] = 0x10; // 0x74 / 4 = 29
}

// Main function
int main() {
    char filename[100];
    
    // Initialize memory and registers
    initialize_memory();
    
    // Get the program file name
    printf("Enter the program file name to run:\n");
    scanf("%s", filename);
    
    // Load instructions from file
    load_instructions(filename);
    
    // Reset PC and cycle count
    pc = 0;
    total_clock_cycles = 0;
    
    // Main execution loop - execute one complete instruction per cycle
    while (pc / 4 < instruction_count) {
        ExecuteOneCycle();
    }
    
    printf("program terminated:\n");
    printf("total execution time is %d cycles\n", total_clock_cycles);
    
    return 0;
}